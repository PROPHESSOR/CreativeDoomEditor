<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title></title>
	<style>
		#canvas {
			position: relative;
			width: 640px;
			height: 480px;
		}

		.background {
			position: absolute;
			background: black;
			width: 100%;
			height: 100%;
		}

		.grid {
			position: absolute;
			background-size: 16px 16px;
			/* TODO: Изменяемый размер сетки */
			background-image: linear-gradient(to right, grey 1px, transparent 1px), linear-gradient(to bottom, grey 1px, transparent 1px);
			width: 100%;
			height: 100%;
		}

		.sector {
			position: absolute;
			background: red;
			/* TODO: Цвет/текстура сектора */
			outline: 2px solid red;
			width: 100%;
			height: 100%;
			clip-path: polygon(0px 0px);
			/* TODO: Система перевода думометров в пиксели */
		}

		.sector-incomplete {
			background: pink !important;
		}

		.sector:hover {
			background: blue;
		}

		.cursor {
			position: absolute;
			/* TODO: Движение за указателем */
			/* Как вариант, вообще можно с помощью cursor: и картинки...
				Но тогда будет сложнее делать привязку к сетке  */
			background: yellow;
			transform: translate(-50%, -50%);
		}

		.vertex {
			position: absolute;
			width: 8px;
			height: 8px;
			background: yellow;
			transform: translate(-50%, -50%)
		}

		.line {
			/* TODO: */
		}
	</style>
</head>

<body>
	<div id="canvas">
		<div class="background"></div>
		<div class="grid"></div>
		<div id="elements">
		</div>
		<!-- <div class="cursor vertex"></div> -->
	</div>

	<script>
		const canvas = document.querySelector('#canvas');
		{
			canvas.events = {};
			canvas.on = (event, func) => {
				if(typeof func !== 'function') throw new TypeError('второй аргумент должен быть функцией!');
				if(!(canvas.events[event] instanceof Array)) canvas.events[event] = [];

				canvas.events[event].push(func);
			}
			canvas.emit = (event, ...args) => {
				if(!(canvas.events[event] instanceof Array)) return false;

				for(const listener of canvas.events[event]) {
					listener(...args);
				}

				return true;
			}
			canvas.state = {
				state: ['drawing', 'sector'] // Состояние
			};
			canvas.setState = (obj) => {
				Object.assign(canvas.state, obj);
				canvas.emit('state.update');
			}

			canvas.setState({});;
		}

		class Vertex {
			constructor([x, y]) {
				[this.x, this.y] = [x, y];
			}

			get identifier() {
				return JSON.stringify(this);
			}

			toUDMF() {
				return `vertex {\n\tx: ${this.x};\n\ty: ${this.y};\n}`;
			}
		}

		class Linedef {
			constructor([v1, v2], vertexes) {
				for(const i in vertexes) {
					const vertex = vertexes[i];

					if(vertex.identifier === v1.identifier) {
						this.v1 = i;
						break;
					}
				}

				if(!this.v1) console.warn('Не могу найти вершину с такими параметрами в списке вершин!', v1);

				for(const i in vertexes) { // TODO: В один цикл
					const vertex = vertexes[i];

					if(vertex.identifier === v2.identifier) {
						this.v2 = i;
						break;
					}
				}

				if(!this.v2) console.warn('Не могу найти вершину с такими параметрами в списке вершин!', v2);
			}
			toUDMF() {
				return `linedef {\n\tv1: ${this.v1};\n\tv2: ${this.v2};\n\tsidefront: 0;\n}`;
			}
		}

		class Sidedef {
			constructor(sector) {
				this.sector = sector;
			}
			toUDMF() {
				return `sidedef {\n\tsector: ${this.sector};\n}`;
			}
		}

		class Sector {
			toUDMF() {
				return `sector {\n}`;
			}

			static createElement() {
				const el = document.createElement('div');
				el.classList.add('sector');
				el.classList.add('sector-incomplete');
				el.path = [];

				el.updatePath = () => {
					el.style.clipPath = `polygon(${el.path.map(e => e.map(e => e + 'px').join(' '))})`;
				};

				document.querySelector('#elements').appendChild(el);

				return el;
			}
		}

		class UDMF {
			constructor(sector) {
				this.vertexes = sector.path.map(e => new Vertex(e));
				this.linedefs = this.vertexes.map((e, i) => i === this.vertexes.length - 1 ? new Linedef([e, this.vertexes[0]], this.vertexes) : new Linedef([e, this.vertexes[i + 1]], this.vertexes));
				this.sidedefs = [new Sidedef(0)];
				this.sectors  = [new Sector()];
			}

			toJSON() {
				return [...this.linedefs, ...this.sidedefs, ...this.vertexes, ... this.sectors];
			}

			toUDMF() {
				let out = '// Generated by CreativeDoomEditor\n\nnamespace = "zdoom";\n\n';

				out += "// Things\n\n";

				out += "// Linedefs\n\n";
				for(const linedef of this.linedefs) { // TODO: В один цикл, или паттерн
					out += linedef.toUDMF();
					out += '\n\n';
				}

				out += "// Sidedefs\n\n";
				for(const sidedef of this.sidedefs) {
					out += sidedef.toUDMF();
					out += '\n\n';
				}

				out += "// Vertexes\n\n";
				for(const vertex of this.vertexes) {
					out += vertex.toUDMF();
					out += '\n\n';
				}

				out += "// Sectors\n\n";
				for(const sector of this.sectors) {
					out += sector.toUDMF();
					out += '\n\n';
				}

				return out;
			}
		}

		const grid = document.querySelector('.grid');
		{
			grid.sizex = 16;
			grid.sizey = 16;
			grid.scale = (x = 16, y = x) => {
				grid.sizex = x;
				grid.sizey = y;
				grid.style.backgroundSize = `${x}px ${y}px`;
			}
		}

		/** Возвращает координаты, привязанные к сетке
		 */
		const round = (x, y) => [Math.floor(x / grid.sizex + .5) * grid.sizex, Math.floor(y / grid.sizey + .5) * grid.sizex];

		window.addEventListener('keydown', (event) => {
			console.log(event.keyCode);

			switch (event.keyCode) {
				case 219:
					grid.scale(grid.sizex >> 1);
					break;
				case 221:
					grid.scale(grid.sizex << 1);
					break;
				default:
					break;
			}
		})

		document.querySelector('#canvas').addEventListener('mousemove', (event) => {
			const [x, y] = [event.offsetX, event.offsetY]
			// console.log(x, y);
			const [xr, yr] = round(x, y);

			// document.querySelector('.cursor').style.left = `${xr}px`;
			// document.querySelector('.cursor').style.top = `${yr}px`;
		}, true)

		document.querySelector('#canvas').addEventListener('mousedown', (event) => {
			if(event.target.classList.contains('vertex')) return;

			const [x, y] = [event.offsetX, event.offsetY]
			console.log(x, y);
			const [xr, yr] = round(x, y);

			const vertex = document.createElement('div');
			vertex.classList.add('vertex');
			vertex.style.left = `${xr}px`;
			vertex.style.top = `${yr}px`;
			document.querySelector('#elements').appendChild(vertex);

			let [state, type, element] = canvas.state.state;

			if(state === 'drawing' && type === 'sector') {
				if(!element) {
					element = Sector.createElement();
					canvas.setState({state: [state, type, element]});
				}

				if(String(element.path[0]) === String([xr, yr])) {
					// Close sector
					element.classList.remove('sector-incomplete');
					canvas.setState({state: [state, type]});
				} else {
					element.path.push([xr, yr]);
					element.updatePath();
				}
			}
		}, true);
	</script>
</body>

</html>

<!-- 

	Состояния:
		drawing
			sector
				{sector}
			vertex
			line
 -->