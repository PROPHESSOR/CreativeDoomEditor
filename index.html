<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title></title>
	<style>
		#canvas {
			position: relative;
			width: 640px;
			height: 480px;
		}

		.background {
			position: absolute;
			background: black;
			width: 100%;
			height: 100%;
		}

		.grid {
			position: absolute;
			background-size: 16px 16px;
			/* TODO: Изменяемый размер сетки */
			background-image: linear-gradient(to right, grey 1px, transparent 1px), linear-gradient(to bottom, grey 1px, transparent 1px);
			width: 100%;
			height: 100%;
		}

		.sector {
			position: absolute;
			background: red;
			/* TODO: Цвет/текстура сектора */
			outline: 2px solid red;
			width: 100%;
			height: 100%;
			clip-path: polygon(0px 0px);
			/* TODO: Система перевода думометров в пиксели */
		}

		.cursor {
			position: absolute;
			/* TODO: Движение за указателем */
			/* Как вариант, вообще можно с помощью cursor: и картинки...
				Но тогда будет сложнее делать привязку к сетке  */
			background: yellow;
			transform: translate(-50%, -50%);
		}

		.vertex {
			position: absolute;
			width: 8px;
			height: 8px;
			background: yellow;
			transform: translate(-50%, -50%)
		}

		.line {
			/* TODO: */
		}
	</style>
</head>

<body>
	<div id="canvas">
		<div class="background"></div>
		<div class="grid"></div>
		<div id="elements">
			<div class="sector"></div>
		</div>
		<!-- <div class="cursor vertex"></div> -->
	</div>

	<script>
		const sector = document.querySelector('.sector'); // FIXME: Remove
		{
			sector.path = [];
			sector.updatePath = () => {
				sector.style.clipPath = `polygon(${sector.path.map(e => e.map(e => e + 'px').join(' '))})`;
			}

			sector.addEventListener('mouseenter', () => {
				sector.style.background = 'blue';
			}, true)

			sector.addEventListener('mouseleave', () => {
				sector.style.background = 'red';
			}, true)
		}

		const grid = document.querySelector('.grid');
		{
			grid.sizex = 16;
			grid.sizey = 16;
			grid.scale = (x = 16, y = x) => {
				grid.sizex = x;
				grid.sizey = y;
				grid.style.backgroundSize = `${x}px ${y}px`;
			}
		}

		/** Возвращает координаты, привязанные к сетке
		 */
		const round = (x, y) => [Math.floor(x / grid.sizex + .5) * grid.sizex, Math.floor(y / grid.sizey + .5) * grid.sizex];

		window.addEventListener('keydown', (event) => {
			console.log(event.keyCode);

			switch (event.keyCode) {
				case 219:
					grid.scale(grid.sizex >> 1);
					break;
				case 221:
					grid.scale(grid.sizex << 1);
					break;
				default:
					break;
			}
		})

		document.querySelector('#canvas').addEventListener('mousemove', (event) => {
			const [x, y] = [event.offsetX, event.offsetY]
			console.log(x, y);
			const [xr, yr] = round(x, y);

			// document.querySelector('.cursor').style.left = `${xr}px`;
			// document.querySelector('.cursor').style.top = `${yr}px`;
		}, true)

		document.querySelector('#canvas').addEventListener('mousedown', (event) => {
			const [x, y] = [event.offsetX, event.offsetY]
			console.log(x, y);
			const [xr, yr] = round(x, y);

			const vertex = document.createElement('div');
			vertex.classList.add('vertex');
			vertex.style.left = `${xr}px`;
			vertex.style.top = `${yr}px`;
			document.querySelector('#elements').appendChild(vertex);

			sector.path.push([xr, yr]);
			sector.updatePath();
		}, true);
	</script>
</body>

</html>